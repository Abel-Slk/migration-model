
//черновик


/*
            
             double[,] MatVekKulSt1 = MatVekKulSt;  //в дальнейшем сделать настоящие индексы и цикл по времени!
                                                   //--а мб вообще не надо создавать новые массивы в кажд момент времени? мб это только в ВМ надо было? Может и не надо! Мб достаточно их просто в кажд момент времени выводить! Е еще куда-то записывать при необходимости! А изначально создавать один массив, который будет меняться - как и в реальной жизни!

            ////"Изменение доли своей культуры j (культурного максимума в векторе страны j) - уменьшение:"
            //MatVekKulSt1[v, posMaxV] = MatVekKulSt[v, posMaxV] - changeForV;

            ////"Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение:"
            //MatVekKulSt1[v, posMaxIz] = MatVekKulSt[v, posMaxIz] + changeForV;


            ////2. Изменение вектора культур мигрантов, приехавших из страны i в страну j:          

            //double[,] MatVekKulMig1 = MatVekKulMig;    //в дальнейшем сделать настоящие индексы и цикл по времени!


            ////"На сколько изменяем:"
            //double changeForIz = (1.0 / 10.0) * MatVekKulMig[v, posMaxV];   //см комментарий к double changeForV выше
            ////или MatVekKulSt?? Ведь влияние идет от страны!! Или это вообще должно быть одно и то же - тк в своей стране нет мигрантов своей культуры!! Так может сделать так, чтобы в м-це культур мигрантов в стране j строчка "мигрантов из страны j" соответствовала просто местной культуре?? Тогда это на самом деле будет не только м-ца культур мигрантов в стране j, а м-ца из векторов культур мигрантов в стране j + вектора культуры самой страны j!!! Те соотв вектора из 2!!! А значит во всем кубе будет умещена вся м-ца 2!!!!!

            ////"Изменение доли своей культуры (своего культурного максимума) - уменьшение:"
            //MatVekKulMig1[iz, posMaxIz] = MatVekKulMig[iz, posMaxIz] - changeForIz;

            ////"Изменение доли культуры страны (культурного максимума страны) - увеличение:"
            //MatVekKulMig1[iz, posMaxV] = MatVekKulMig[iz, posMaxV] + changeForIz;
            */



//Исходная матрица векторов культур мигрантов, живущих в стране j (/приезжающих в эту страну):
//double[,] MatVekKulMig = new double[5, 5] {
//                                     { 1.0,  0.0,  0.0,  0.0,  0.0 },
//                                     { 0.0,  1.0,  0.0,  0.0,  0.0 },
//                                     { 0.0,  0.0,  1.0,  0.0,  0.0 },
//                                     { 0.0,  0.0,  0.0,  1.0,  0.0 },
//                                     { 0.0,  0.0,  0.0,  0.0,  1.0 },
//                                    };


//Найдем значение и порядковый номер макс культуры мигранта, значение и порядковый номер принимающей страны:
//            for (int l = 0; l<MatVekKulSt.GetLength(0); l++)     
//            {               
//                for (int m = 0; m<MatVekKulSt.GetLength(1); m++)
//                {
//                    if (l == iz)
//                    {

//                        if (maxIz<MatVekKulSt[l, m])
//                        {
//                            maxIz = MatVekKulSt[l, m];
//                            posMaxIz = m;                            //posMaxIz = Array.IndexOf(MatVekKulSt, MatVekKulSt[l, m]); //так можно только для одномерных массивов?
//                        }

//                    }

//                    if (l == v)
//                    {

//                        if (maxV<MatVekKulSt[l, m])
//                        {
//                            maxV = MatVekKulSt[l, m];
//                            posMaxV = m;                            
//                        }

//                    }

//                }
//            }



//{    { 0.0,  1.0,  0.0,  0.0,  0.0 }, { 0.0,  1.0,  0.0,  0.0,  0.0 },  { 0.0,  1.0,  0.0,  0.0,  0.0 },  { 0.0,  1.0,  0.0,  0.0,  0.0 }, { 0.0,  1.0,  0.0,  0.0,  0.0 }    },
//{    { 0.0,  0.0,  1.0,  0.0,  0.0 }, { 0.0,  0.0,  1.0,  0.0,  0.0 },  { 0.0,  0.0,  1.0,  0.0,  0.0 },  { 0.0,  0.0,  1.0,  0.0,  0.0 }, { 0.0,  0.0,  1.0,  0.0,  0.0 }    },
//{    { 0.0,  0.0,  0.0,  1.0,  0.0 }, { 0.0,  0.0,  0.0,  1.0,  0.0 },  { 0.0,  0.0,  0.0,  1.0,  0.0 },  { 0.0,  0.0,  0.0,  1.0,  0.0 }, { 0.0,  0.0,  0.0,  1.0,  0.0 }    },
//{    { 0.0,  0.0,  0.0,  0.0,  1.0 }, { 0.0,  0.0,  0.0,  0.0,  1.0 },  { 0.0,  0.0,  0.0,  0.0,  1.0 },  { 0.0,  0.0,  0.0,  0.0,  1.0 }, { 0.0,  0.0,  0.0,  0.0,  1.0 }    },
//  };


//double[,,] MatVekKulMigF = new double[5, 5, 5] {
//                                  {    { 1.0,  0.0,  0.0,  0.0,  0.0 }, { 1.0,  0.0,  0.0,  0.0,  0.0 },  { 1.0,  0.0,  0.0,  0.0,  0.0 },  { 1.0,  0.0,  0.0,  0.0,  0.0 }, { 1.0,  0.0,  0.0,  0.0,  0.0 }    },
//                                  {    { 0.0,  1.0,  0.0,  0.0,  0.0 }, { 0.0,  1.0,  0.0,  0.0,  0.0 },  { 0.0,  1.0,  0.0,  0.0,  0.0 },  { 0.0,  1.0,  0.0,  0.0,  0.0 }, { 0.0,  1.0,  0.0,  0.0,  0.0 }    },
//                                  {    { 0.0,  0.0,  1.0,  0.0,  0.0 }, { 0.0,  0.0,  1.0,  0.0,  0.0 },  { 0.0,  0.0,  1.0,  0.0,  0.0 },  { 0.0,  0.0,  1.0,  0.0,  0.0 }, { 0.0,  0.0,  1.0,  0.0,  0.0 }    },
//                                  {    { 0.0,  0.0,  0.0,  1.0,  0.0 }, { 0.0,  0.0,  0.0,  1.0,  0.0 },  { 0.0,  0.0,  0.0,  1.0,  0.0 },  { 0.0,  0.0,  0.0,  1.0,  0.0 }, { 0.0,  0.0,  0.0,  1.0,  0.0 }    },
//                                  {    { 0.0,  0.0,  0.0,  0.0,  1.0 }, { 0.0,  0.0,  0.0,  0.0,  1.0 },  { 0.0,  0.0,  0.0,  0.0,  1.0 },  { 0.0,  0.0,  0.0,  0.0,  1.0 }, { 0.0,  0.0,  0.0,  0.0,  1.0 }    },
//                                    };



//Перед тем как полностью убрать MatVekKulSt, надо сделать извлечение аналогичной м-цы из куба MatVekKulMigF!
//Исходная матрица векторов культур стран (по строкам):
//в дальнейшем сделать создание таких м-ц в цикле по времени! И у м-ц должны быть настоящие индексы! Нав надо использ "массив из объектов", где объектами будут эти м-цы??
//double[,] MatVekKulSt = new double[5, 5] {
//                                     { 1.0,  0.0,  0.0,  0.0,  0.0 },
//                                     { 0.0,  1.0,  0.0,  0.0,  0.0 },
//                                     { 0.0,  0.0,  1.0,  0.0,  0.0 },
//                                     { 0.0,  0.0,  0.0,  1.0,  0.0 },
//                                     { 0.0,  0.0,  0.0,  0.0,  1.0 },
//                                    };




//если будет время - оформить поиск макс в отдел ф-ию типа как ниже - только видимо 4ре изменяемых пар-ра надо вводить как аргументы ф-ии с ref?
//static void getMaxAndPosMax(double[,,] MatVekKulMig, int from, int to, double maxFrom, int posMaxFrom, double maxTo, int posMaxTo)
//{
//    for (int l = 0; l < MatVekKulMig.GetLength(0); l++)
//    {
//        for (int m = 0; m < MatVekKulMig.GetLength(1); m++)
//        {
//            for (int n = 0; n < MatVekKulMig.GetLength(2); n++)
//            {
//                if (l == from && m == from)    //мб как и ниже надо добавить еще выбор в зав-ти от того, новая волны или нет?
//                {
//                    if (maxFrom < MatVekKulMig[l, m, n])
//                    {
//                        maxFrom = MatVekKulMig[l, m, n];
//                        posMaxFrom = n;   //в posMaxIz надо записать последний из индексов, тк далее он будет использоваться всегда на месте последнего индекса                          
//                    }
//                }

//                if (l == to && m == to)
//                {
//                    if (maxTo < MatVekKulMig[l, m, n])
//                    {
//                        maxTo = MatVekKulMig[l, m, n];
//                        posMaxTo = n;
//                    }
//                }
//            }


//        }
//    }

//    //maxIz = maxFrom;      //так нельзя - надо иметь левые части параметрами! Но мб можно всего этого не делать, если в имеющиеся параметры добавить &? Что аргументы брались не по значению, а по адресу?
//    //posMaxIz = posMaxFrom;
//    //maxV = maxTo;
//    //posMaxV = posMaxTo;
//}



//bool newMigWave = true; //вывести в параметр ф-ии! Чтобы при каждой новой итерации это можно было задать!
//if (newMigWave) changeForV = coeff_changeForV * MatVekKulMig[iz, iz, posMaxIz]; // если это новые мигранты из страны i в страну j, то изменение местной культуры происходит под влиянием макс культуры страны i к текущему шагу
//else changeForV = coeff_changeForV * MatVekKulMig[v, iz, posMaxIz]; //если же это мигранты из страны i, которые на предыд шаге уже жили в стране j, то изменение местной культуры происходит под влиянием макс культуры этих мигрантов, а не макс культуры в стране i к текущему шагу. (Со временем культура мигрантов из i и культура в их родной стране i будут все сильнее расходиться


//change(MatVekKulMigF);
////change(MatVekKulMigF, iz, v, takty);

////начиная отсюда все оформить как ф - ию - и тогда из и в вводить как параметры -- или внутри ф-ии брать из ReadKey()? 
////номер страны, откуда будет волна мигрантов:
//int iz = 0;     //потом сделать ReadKey() 

////номер принимающей страны:
//int v = 4;




//    //Найдем значение и порядковый номер макс культуры мигранта, значение и порядковый номер принимающей страны:

//double maxIz = 0;
//int posMaxIz = -1;  //-1 - те пока позиции нет

//double maxV = 0;
//int posMaxV = -1;            

//for (int l = 0; l < MatVekKulMigF.GetLength(0); l++)
//{
//    for (int m = 0; m < MatVekKulMigF.GetLength(1); m++)
//    {
//        for (int n = 0; n < MatVekKulMigF.GetLength(2); n++)
//        {
//            if (l == iz && m == iz)    //мб как и ниже надо добавить еще выбор в зав-ти от того, новая волны или нет?
//            {
//                if (maxIz < MatVekKulMigF[l, m, n])
//                {
//                    maxIz = MatVekKulMigF[l, m, n];
//                    posMaxIz = n;   //в posMaxIz надо записать последний из индексов, тк далее он будет использоваться всегда на месте последнего индекса                          
//                }
//            }

//            if (l == v && m == v)
//            {
//                if (maxV < MatVekKulMigF[l, m, n])
//                {
//                    maxV = MatVekKulMigF[l, m, n];
//                    posMaxV = n;
//                }
//            }
//        }


//    }
//}


//System.Console.WriteLine("Значение макс культуры мигранта: {0}", maxIz);
//System.Console.WriteLine("Номер макс культуры мигранта: {0} \n", posMaxIz);

//System.Console.WriteLine("Значение макс культуры принимающей страны: {0}", maxV);
//System.Console.WriteLine("Номер макс культуры принимающей страны: {0} \n", posMaxV);

//System.Console.WriteLine();





////сделать в виде ф-ии? Делающией изменение типа за 1 такт? Кот сколько раз вызовешь, столько и будет итераций? И необходимое кол-во тактов можно задать, просто вызвав ф-ию в цикле сколько нужно раз! А индексы и не нужны, если одну и ту же структуру перезаписывать??


////На сколько изменяем вектор культур страны j (v) под влиянием мигрантов из страны i (iz): 
//double changeForV;
//double coeff_changeForV = 1.0 / 100.0;  //Вместо коэф-та (1.0 / 100.0) потом сделать некоторую зависимость от численностей населения 3D-массива населения?
//bool newMigWave = true; //мб вывести в параметр ф-ии! Чтобы при каждой новой итерации это можно было задать!
//if (newMigWave) changeForV = coeff_changeForV * MatVekKulMigF[iz, iz, posMaxIz]; // если это новые мигранты из страны i в страну j, то изменение местной культуры происходит под влиянием макс культуры страны i к текущему шагу
//else            changeForV = coeff_changeForV * MatVekKulMigF[v, iz, posMaxIz]; //если же это мигранты из страны i, которые на предыд шаге уже жили в стране j, то изменение местной культуры происходит под влиянием макс культуры этих мигрантов, а не макс культуры в стране i к текущему шагу. (Со временем культура мигрантов из i и культура в их родной стране i будут все сильнее расходиться

////На сколько изменяем вектор культур мигрантов, приехавших из страны i в страну j: 
//double changeForIz; //changeForV зависела от newMigWave, а для changeForIz подобной зависимости нет
//double coeff_changeForIz = 1.0 / 10.0;  //Вместо коэф-та потом сделать некоторую зависимость от численностей населения 3D-массива населения?
//changeForIz = coeff_changeForIz * MatVekKulMigF[v, v, posMaxV];        


////1. Изменение вектора культур страны j (v) под влиянием мигрантов из страны i (iz):
////"Изменение доли своей культуры j в стране j (своего культурного максимума) - уменьшение:"
//MatVekKulMigF[v, v, posMaxV] -= changeForV;    //[v, v, posMaxV] значит идем в строку v куба - попадаем в м-цу. В ней выбираем строку v и столбец posMaxV

////"Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение:"
//MatVekKulMigF[v, v, posMaxIz] += changeForV;


////2. Изменение вектора культур мигрантов, приехавших из страны i в страну j:  

////"Изменение доли своей культуры (своего культурного максимума) - уменьшение:"
//MatVekKulMigF[v, iz, posMaxIz] -= changeForIz;

////"Изменение доли культуры страны (культурного максимума страны) - увеличение:"
//MatVekKulMigF[v, iz, posMaxV] += changeForIz;


////"К концу первого шага имеем:"
//System.Console.WriteLine("-----------------------------После 1го такта:-------------------------------");
//arrOut3D(MatVekKulMigF);
//MatVekKulStOut(MatVekKulMigF);


//System.Console.WriteLine("Исходная м-ца в-ров культур стран (по строкам): ");
////arrOut(MatVekKulSt);
//System.Console.WriteLine();





//else if (newMigWave == 2)   //если это новая волна + есть мигранты из страны i, которые на предыд шаге уже жили в стране j, то будем считать это за двойное воздействие на страну j
//{
//    changeForV = coeff_changeForV * (MatVekKulMig[iz, iz, posMaxIz] + MatVekKulMig[v, iz, posMaxIz]);
//    System.Console.WriteLine("На сколько изменяем вектор культур страны j (v) под влиянием мигрантов из страны i (iz):\n{0}", changeForV);
//}
//else - throw exception

//if(bool migAlreadyPresent)//если мигранты из страны i к данному шагу уже есть в стране j и не уезжают из нее, то сделать влияние на данную страну двойным - как сумму культур 





//создание 3D-массива населения (пар-педа): возраст (3 группы - дети, взрослые, старики), образование (2 уровня), культура (5 уровней -по числу стран)
//int[,,] populArray = new int[3, 2, 5]{                                       
//                                            {   {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}    },   //строка 1 (из двух векторов вверх)
//                                            {   {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20} },   //строка 2 (-//-)
//                                             {   {11, 12, 13, 14, 15}, {16, 17, 18, 19, 20} }
//                                        };

//вывод массива:
//for (int l = 0; l < populArray.GetLength(0); l++)           
//{
//    System.Console.WriteLine("фиксируем строку плоской м-цы:");//выше

//    for (int m = 0; m < populArray.GetLength(1); m++)
//    {
//        System.Console.WriteLine("фиксируем столбец плоской м-цы):");//выше

//        System.Console.WriteLine("заполянем в-р-столбец вверх:");//ниже
//        for (int n = 0; n < populArray.GetLength(2); n++)
//        {
//            System.Console.WriteLine("эл-т № {0},{1},{2}", l, m, n);
//            System.Console.WriteLine(populArray[l, m, n]);
//        }
//        System.Console.WriteLine();
//    }
//    System.Console.WriteLine();
//}





//double[,,] populArr = new double[3, 2, 5] {//по систаксису похоже мне это и нужно - сравни с выше! И я же и хотел по изнач рисунку 3 чтобы одной стране соответствовал один слой! И сделать так, чтобы стране соответствовала одна строка, вполне можно! См ех рис "3small": см на 1ю строку - в ней если выстроить все столбики "монеток", то можно получить 1ю м-цу! А вторую - во второй строке!
//                                  {//строка 0:          
//                                     { 1.0,  0.0,  0.0,  0.0,  0.0 },   //что в стоблце 0 строки 0 - те столбец вверх
//                                     { 0.0,  1.0,  0.0,  0.0,  0.0 },
//                                  },
//                                  {//строка 1:          
//                                     { 1.0,  0.0,  0.0,  0.0,  0.0 },   //что в стоблце 0 строки 0 - те столбец вверх
//                                     { 0.0,  1.0,  0.0,  0.0,  0.0 },
//                                  },
//                                  {//строка 2:          
//                                     { 1.0,  0.0,  0.0,  0.0,  0.0 },   //что в стоблце 0 строки 0 - те столбец вверх
//                                     { 0.0,  1.0,  0.0,  0.0,  0.0 },
//                                  }
//                            };





//static void part3()
//{
//    //double [] sum = new double [5];

//    State[] st = new State[5]; //массив объектов
//    for (int i = 0; i < 5; i++)
//    {
//        st[i] = new State();

//        //st[i].population = 
//        //st[i].myIn() // сделать ф-ю для вычисления и присвоения значений для всех св-в сразу? 

//        //System.Console.WriteLine("Страна {0}:", i);
//        //System.Console.WriteLine("характеристика населения: {0}", st[i].population);
//        //System.Console.WriteLine("уровень производственных мощностей: {0}", st[i].production); 
//        //System.Console.WriteLine("уровень образования: {0}", st[i].education);
//        //System.Console.WriteLine("уровень недовольства: {0}", st[i].socialConditions);
//        //System.Console.WriteLine();
//    }

//    //populationCount(populationArray, state);

//    //double[] sum = new double[5];

//    //for (int s = 0; s < arr.GetLength(0); s++)  //фиксируем пар-пед страны внутри пар-педа всех стран 
//    //{
//    //    for (int i = 0; i < arr.GetLength(1); i++)  //фиксируем возраст
//    //    {
//    //        for (int j = 0; j < arr.GetLength(2); j++)  //фиксируем образование
//    //        {
//    //            for (int k = 0; k < arr.GetLength(3); k++)  //пробегаем все культуры
//    //            {
//    //                summa[s] += arr[s, i, j, k];
//    //            }
//    //        }
//    //    }
//    //    st[s].population = summa[s];
//    //    System.Console.WriteLine("Общая числ насел в стране {0}:", s);
//    //}


//}





//public static void iteratedChange(ref double[,,] MatVekKulMig) // изменение культур по тактам
//{
//    System.Console.WriteLine("Введите количество тактов:");
//    int NumOfIterations = int.Parse(System.Console.ReadLine());   //= 1;

//    for (int t = 0; t < NumOfIterations; t++)
//    {
//        change(MatVekKulMig);

//        //К концу шага имеем:     
//        System.Console.WriteLine("-----------------------------После такта №{0}:-------------------------------", t);
//        arrOut3D(MatVekKulMig);
//        MatVekKulStOut(MatVekKulMig);

//    }
//}

//double coeff_changeForIz = 1.0 / 10.0;  //Вместо коэф-та потом сделать некоторую зависимость от численностей населения 3D-массива населения?








//if (iz == v)    //Если это одна и та же страна, а не поток между двумя различным странами, то перейдем к рассмотрению культурных процессов внутри одной страны. (Для этого ниже перейдем к матрице культур данной страны и будем работать с ней внутри двойного цикла for.)
//                        {
//                            int indexOfLocCult = v; //сохраним номер местной культуры. (Порядковый номер страны совпадает с порядковым номером культуры, что и будет использовано далее.)

//double[] max = { 0.0, 0.0, 0.0, 0.0, 0.0 };
//int[] posMax = { -1, -1, -1, -1, -1 };

//                            for (int i = 0; i< 5; i++)   //пробегаем строки матрицы данной страны
//                            {                           
//                                for (int j = 0; j< 5; j++)   //пробегаем столбцы каждой строки, чтобы найти макс в этой строке
//                                {
//                                    //Найдем максимумы своей культуры и максимумы мигрантских культур в данной стране:

//                                    //if (i == indexOfLocCult)    //если мы в строке СВОЕЙ культуры, найдем свой макс:
//                                    //{
//                                    //    if (max[i] < cultStruct[indexOfLocCult, indexOfLocCult, j]) //maxLoc//или лучше max[i]? Так лучше если мы вместе будем использовать свой макс и мигрантские - а мы будем? В одной фле? Пока не ясно--елс и нет, то можно и созранять отдельно
//                                    //    {
//                                    //        max[i] = cultStruct[indexOfLocCult, indexOfLocCult, j];
//                                    //        posMax[i] = j;
//                                    //    }
//                                    //}

//                                    //else     // если мы в других строках, найдем максимумы каждой мигрантской группы i:
//                                    //{
//                                        if (max[i] < cultStruct[indexOfLocCult, i, j]) //maxMig[i]//или лучше max[i]?
//                                        {
//                                            max[i] = cultStruct[indexOfLocCult, i, j];
//                                            posMax[i] = j;   //в posMaxIz надо записать последний из индексов, тк далее posMaxIz будет использоваться всегда на месте последнего индекса                          
//                                        }
//                                    /*}*///а раздельный поиск своего и чужих макс нужен вообще? Код эквивалентен же получается? Вот ниже в случае не одной страны, а пары (потока) код должен разный быть - а здесь мб и не нужен разный!
//                                    //System.Console.WriteLine(posMax[i]);
//                                }
//                                System.Console.WriteLine("---");
//                                System.Console.WriteLine("indexOfLocCult: {0}, i: {1}, posMax[i]: {2}", indexOfLocCult, i, posMax[i]);//почему-то делает на одну итерацию больше?? Находит не пять позиций, а 6?? И пять находит правильно, а шестой посчему-то присваивает номер позиции 0?? Те j=0 получается? Мб он уже начанает новый внешний цикл?--Мб ему нужен не пятиместный макс и поз, а 25-местный? Но я думал что достаточно 5 мест, чтобы он их перезаписывал при каждой новой итерации внешнего цикла?Но ведь раз он выдает ошибку на 750й строке, кот еще внутри внешнего цикла по i (те самая первая итерация в нем еще не закончена), то не должно быть еще перехода на след итерацию ! Мы все еще должны быть в первой! Те при i=0!
//                                System.Console.WriteLine("---");


//                                //посчитаем численность культурной группы i в данной стране:
//                                double[] sum = new double[5];
//                                for (int s = 0; s<populArr.GetLength(0); s++)  //фиксируем пар-пед страны внутри пар-педа всех стран 
//                                {
//                                    for (int x = 0; x<populArr.GetLength(1); x++)  //фиксируем возраст
//                                    {
//                                        for (int y = 0; y<populArr.GetLength(2); y++)  //фиксируем образование
//                                        {
//                                            for (int z = 0; z<populArr.GetLength(3); z++)  //пробегаем все культуры - выбирая только нужную
//                                            {
//                                                if (z == i)  sum[i] += populArr[s, x, y, z]; 
//                                            }
//                                        }
//                                    }
//                                }

//                                //coeff_changeForV = populationCountOfThisMigGroup[i];//считаем насел гуппы мигрантов строки (культуры) i
//                                //--или лучше свою группу тоже включить? Тогда:
//                                //coeff_changeForV = populationCountOfThisGroup[i];
//                                //или мб свою группу не считать? Она же не должна вносить изменение! если чужих нет совсем, то никаких изменений и не долно происходить! Поэтому свой макс надо бы исключить из учета в изменении changeForV!

//                                //if (i != indexOfLocCult) //определим значение влияния каждой мигрансткой культуры i на местную и произведем перераспределение культур между парой "своя культ - мигрансткая культура i". И так будет происходить для каждой i (за исключением i=indexOfLocCult - в этом случае никаких изменений делать не требуется)
//                                //{// или этот иф не обязателен? Тк в случчае одной и той же культуры отнимем от одного значения и добавим к тому же? Что ничего и не изменит, и поэтому можно условий не ставить?
//                                    coeff_changeForV = a* sum[i];

//changeForV = coeff_changeForV* cultStruct[indexOfLocCult, i, posMax[i]];

////changeForV += (coeff_changeForV * cultStruct[indexOfLocCult, i, posMax[i]];//нав не надо плюсовать - нав надо все влияния делать по отдельности! 
////changeForV += 1 / 4 * (coeff_changeForV * cultStruct[indexOfLocCult, i, posMax[i]]);//не, в 1/4 нав смысла нет - мне на самом деле же надо учесть влияние каждой игрантской группы на местных - и сделать это надо перераспределением значений между парой значений в векторе местной культуры! Мб для этого все-таки приделтся делать changeForV[i]?
////totalChangeForV += changeForV;
////System.Console.WriteLine("На сколько изменяем вектор культур страны j (v) под влиянием мигрантов из страны i (iz):\n{0}", changeForV);

////System.Console.WriteLine(posMax[indexOfLocCult]);

////далее перераспределяем значения культур между парой элементов в строке вектора местной культуры:
//System.Console.WriteLine("***");

//                                    cultStruct[indexOfLocCult, indexOfLocCult, posMax[i]] += changeForV;   //Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение
//                                    System.Console.WriteLine("cultStruct[indexOfLocCult, indexOfLocCult, posMax[i]]: {0}", cultStruct[indexOfLocCult, indexOfLocCult, posMax[i]]);

//                                    cultStruct[indexOfLocCult, indexOfLocCult, posMax[indexOfLocCult]] -= changeForV;    //Изменение доли своей культуры j в стране j (своего культурного максимума) - уменьшение//[v, v, posMaxV] значит, что идем в "строку" v куба - попадаем в м-цу. В ней выбираем строку v и столбец posMaxV                        
//                                    System.Console.WriteLine("cultStruct[indexOfLocCult, indexOfLocCult, posMax[indexOfLocCult]]: {0}", cultStruct[indexOfLocCult, indexOfLocCult, posMax[indexOfLocCult]]);

//                                    System.Console.WriteLine("***");



//                                //}

//                            }



//                        }   //конец обработки процессов внутри одной страны






//double[] max = { 0.0, 0.0, 0.0, 0.0, 0.0 };
//int[] posMax = { -1, -1, -1, -1, -1 };

//                            for (int i = 0; i< 5; i++)   //пробегаем строки матрицы данной страны
//                            {
//                                for (int j = 0; j< 5; j++)   //пробегаем столбцы каждой строки, чтобы найти макс в этой строке
//                                {
//                                    //Найдем культурные максимумы каждой из культур страны (макс своей культуры и максимумы мигрантских культур)

//                                    //if (i == indexOfLocCult)    //если мы в строке СВОЕЙ культуры, найдем свой макс:
//                                    //{
//                                    //    if (max[i] < cultStruct[indexOfLocCult, indexOfLocCult, j]) //maxLoc//или лучше max[i]? Так лучше если мы вместе будем использовать свой макс и мигрантские - а мы будем? В одной фле? Пока не ясно--елс и нет, то можно и созранять отдельно
//                                    //    {
//                                    //        max[i] = cultStruct[indexOfLocCult, indexOfLocCult, j];
//                                    //        posMax[i] = j;
//                                    //    }
//                                    //}

//                                    //else     // если мы в других строках, найдем максимумы каждой мигрантской группы i:
//                                    //{
//                                    if (max[i] < cultStruct[indexOfLocCult, i, j]) //maxMig[i]//или лучше max[i]?
//                                    {
//                                        max[i] = cultStruct[indexOfLocCult, i, j];
//                                        posMax[i] = j;   //в posMaxIz надо записать последний из индексов, тк далее posMaxIz будет использоваться всегда на месте последнего индекса                          
//                                    }
//                                    /*}*///а раздельный поиск своего и чужих макс нужен вообще? Код эквивалентен же получается? Вот ниже в случае не одной страны, а пары (потока) код должен разный быть - а здесь мб и не нужен разный!
//                                    //System.Console.WriteLine(posMax[i]);
//                                }
//                            }  







//public static void cultChange(ref double[,,] cultStruct, State[] state, double[,,,] populArr) // изменение культур по тактам. 
//                                                                                              //Как считается:
//                                                                                              //влияние на местное население в стране А зависит от размера входящего потока из В в А
//                                                                                              //влияние на мигрантов является функцией от численности местного населения, у которого культура не совпадает с мигрантской. 
//{
//    System.Console.WriteLine("Введите количество тактов:");
//    int NumOfIterations = int.Parse(System.Console.ReadLine());   //= 1;

//    for (int t = 0; t < NumOfIterations; t++)
//    {

//        System.Console.WriteLine("Введите количество пар стран, между которыми на данном шаге будут потоки мигрантов:");
//        int NumOfPairs = int.Parse(System.Console.ReadLine());

//        for (int p = 0; p < NumOfPairs; p++)
//        {
//            System.Console.WriteLine("Введите номер страны, откуда будет волна мигрантов / откуда мигранты, уже находящиеся в стране и остающиеся там на данном шаге:");
//            int iz = int.Parse(System.Console.ReadLine());  //= 0;     

//            System.Console.WriteLine("Введите номер принимающей страны:");
//            int v = int.Parse(System.Console.ReadLine());   //= 4;


//            //Найдем значение и порядковый номер макс культуры мигранта, значение и порядковый номер принимающей страны:

//            double maxIz = 0;
//            int posMaxIz = -1;  //-1 - те пока позиции нет

//            double maxV = 0;
//            int posMaxV = -1;

//            for (int l = 0; l < cultStruct.GetLength(0); l++)
//            {
//                for (int m = 0; m < cultStruct.GetLength(1); m++)
//                {
//                    for (int n = 0; n < cultStruct.GetLength(2); n++)
//                    {
//                        if (l == iz && m == iz)    //мб как и ниже надо добавить еще выбор в зав-ти от того, новая волны или нет?
//                        {
//                            if (maxIz < cultStruct[l, m, n])
//                            {
//                                maxIz = cultStruct[l, m, n];
//                                posMaxIz = n;   //в posMaxIz надо записать последний из индексов, тк далее он будет использоваться всегда на месте последнего индекса                          
//                            }
//                        }

//                        if (l == v && m == v)
//                        {
//                            if (maxV < cultStruct[l, m, n])
//                            {
//                                maxV = cultStruct[l, m, n];
//                                posMaxV = n;
//                            }
//                        }
//                    }


//                }
//            }

//            System.Console.WriteLine();
//            System.Console.WriteLine("Значение макс культуры мигранта (из страны №{0}):\n{1}", iz, maxIz);
//            System.Console.WriteLine("Номер макс культуры мигранта (из страны №{0}):\n{1}\n", iz, posMaxIz);

//            System.Console.WriteLine("Значение макс культуры принимающей страны (страна №{0}):\n{1}", v, maxV);
//            System.Console.WriteLine("Номер макс культуры принимающей страны (страна №{0}):\n{1} \n", v, posMaxV);
//            System.Console.WriteLine();




//            //На сколько изменяем вектор культур страны j (v) под влиянием мигрантов из страны i (iz): 
//            double changeForV = 0.0;
//            double a = 0.001;  //нек коэф-т 
//            double coeff_changeForV = a * state[iz].flowSize[v]; //коэф-т влияния на местное население в В зависит от размера входящего потока из А в В

//            System.Console.WriteLine("Если на данном такте это новая волна мигрантов, введите 1; если это мигранты, которые на предыдущем шаге уже жили в данной стране, введите 0. (Случай новой волны при наличии уже живущих мигрантов считать равносильным воздействию новой волны.)");
//            int newMigWave = int.Parse(System.Console.ReadLine());

//            if (newMigWave == 1)    // если это новые мигранты из страны i в страну j, то изменение местной культуры происходит под влиянием макс культуры страны i к текущему шагу
//            {
//                changeForV = coeff_changeForV * cultStruct[iz, iz, posMaxIz];//то есть окончательно влияние на местное население в В зависит от размера входящего потока из А в В и от культуры в А
//                System.Console.WriteLine("На сколько изменяем вектор культур страны j (v) под влиянием мигрантов из страны i (iz):\n{0}", changeForV);
//            }

//            else if (newMigWave == 0)   //если же это мигранты из страны i, которые на предыд шаге уже жили в стране j, то изменение местной культуры происходит под влиянием макс культуры этих мигрантов, а не макс культуры в стране i к текущему шагу. (Со временем культура мигрантов из i и культура в их родной стране i будут все сильнее расходиться.)
//            {
//                changeForV = coeff_changeForV * cultStruct[v, iz, posMaxIz];
//                System.Console.WriteLine("На сколько изменяем вектор культур страны j (v) под влиянием мигрантов из страны i (iz):\n{0}", changeForV);
//            }
//            //Замечание: случай новой волны при наличии уже живущих мигрантов считаем равносильным воздействию новой волны




//            //На сколько изменяем вектор культур мигрантов, приехавших из страны i в страну j: 
//            double changeForIz; //changeForV зависела от newMigWave, а для changeForIz подобной зависимости нет

//            double sum = 0;

//            //Посчитаем числ насел в стране v, где культура не совпадает с культурой iz:
//            for (int i = 0; i < populArr.GetLength(1); i++)  //фиксируем возраст GetLength(1), а не GetLength(0), тк последнее будет пробегать не по возрастам а странам - а у нас страна уже выбрана, поэтому начинаем сразу со второй размерности массива - те с 1
//            {
//                for (int j = 0; j < populArr.GetLength(2); j++)  //фиксируем образование
//                {
//                    for (int k = 0; k < populArr.GetLength(3); k++)  //пробегаем все культуры
//                    {
//                        if (k != iz) sum += populArr[v, i, j, k];
//                    }
//                }
//            }

//            double coeff_changeForIz = 1.0 - 1.0 / sum;  //влияние на мигрантов является функцией от суммы численности местного населения sum, у которого культура не совпадает с мигрантской. 
//                                                         //Как считается: сумме sum ставим в соответствие нек число между 0 и 1, чтобы коэф-т coeff_changeForIz был похож по величине на coeff_changeForV. Для этого делим 1.0 / sum. Но здесь чем больше сумма, тем меньше будет дробь, а нам нужно наоборот (чем больше население другой культуры, тем больше должно быть влияние), поэтому будем вычитать эту величину из единицы: 1.0 - 1.0 / sum.

//            changeForIz = coeff_changeForIz * cultStruct[v, v, posMaxV];    //окончательное влияние на мигрантов будет зависеть от численности населения других культур и от преобладающей местной культуры
//            System.Console.WriteLine("На сколько изменяем вектор культур мигрантов, приехавших из страны i (iz) в страну j (v):\n{0}", changeForIz);

//            //1. Изменение вектора культур страны j (v) под влиянием мигрантов из страны i (iz):
//            //Изменение доли своей культуры j в стране j (своего культурного максимума) - уменьшение:
//            cultStruct[v, v, posMaxV] -= changeForV;    //[v, v, posMaxV] значит, что идем в "строку" v куба - попадаем в м-цу. В ней выбираем строку v и столбец posMaxV

//            //Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение:
//            cultStruct[v, v, posMaxIz] += changeForV;


//            //2. Изменение вектора культур мигрантов, приехавших из страны i в страну j:  
//            //Изменение доли своей культуры (своего культурного максимума) - уменьшение:
//            cultStruct[v, iz, posMaxIz] -= changeForIz;

//            //Изменение доли культуры страны (культурного максимума страны) - увеличение:
//            cultStruct[v, iz, posMaxV] += changeForIz;

//        }


//        //К концу шага имеем:     
//        System.Console.WriteLine("-----------------------------После такта №{0}:-------------------------------", t);
//        arrOut3D(cultStruct);
//        MatVekKulStOut(cultStruct);
//    }

//}



//currCultStr = cultureStructure;
//dataItemsList.Add(currCultStr);//добавляет не знач, а ссылку!!
//dataItems.Add(dataItemsList);

//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    System.Console.WriteLine("copied to list: {0}\t", dataItems[0][t][0, 1, i]);//здесь все выводит правильно!
//}
//System.Console.WriteLine();

//currCultStrForList3.Add(cultureStructure);


//currCultStrForList2.Add(cultureStructure);


//currCultStr = cultureStructure; //currCultStr~~piece?
//currCultStrForList.Add(cultureStructure); //currCultStrForList~~currentWord?
////arrayList = currCultStrForList;
//arrayList.AddRange(currCultStrForList);



//arrayList.Add(currCultStrForList);



//arrayList.Add(cultureStructure);    //arrList заполняется правильно, но в программе список заполняется одинаковыми элзми - последними!

//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    //System.Console.Write("in current cultStruct: {0}\t", cultStruct[0, 1, i]);
//    System.Console.WriteLine("copied to list: {0}\t", arrayList[t][0, 1, i]);//здесь все выводит правильно!
//}
//System.Console.WriteLine();


//jaggedArray[t] = cultureStructure;//почему опять все разы присваивается только последний эл-т??

//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    System.Console.Write("x: {0}, y: {1}\t", i, jaggedArray[t][0, 1, i]);//здесь все выводит правильно!
//}


//Program.jaggedArray[t] = cultStruct;
//jaggedArr[t] = cultStruct;
//Array.Copy(cultStruct, jaggedArr[t], 125);
//if (t == 1) cc = cultStruct;




//al.AddRange(arrayList);

//System.Console.WriteLine("outside of iter loop:");
//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    System.Console.Write("x: {0}, y: {1}\t", i, jaggedArray[1][0, 1, i]);
//}

//last
//System.Console.WriteLine("outside of iter loop:");
//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    System.Console.Write("x: {0}, y: {1}\t", i, arrayList[0][0, 1, i]);
//}


//System.Console.WriteLine("outside of iter loop:");
//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    System.Console.Write("x: {0}, y: {1}\t", i, dataItems[1][0][0, 1, i]);//второй индекс у dataItems опытным путем должен быть 0 всегда, а первый можно менять
//}



//System.Console.WriteLine("outside of iter loop:");
//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    System.Console.Write("x: {0}, y: {1}\t", i, al[0][0, 1, i]);
//}





//for (int i = 0; i < State.numberOfCountries; i++)
//{
//    System.Console.WriteLine("copied to list: {0}\t", arrayList[t][0, 1, i]);//здесь все выводит правильно!
//}
//System.Console.WriteLine();



//public static double[][,,] jaggedArray = new double[100][,,];

//public static int NumOfIter;



//public static double[,,] currCultStr;// = new double [5,5,5];

//public static List<double[,,]> currCultStrForList; 






//double[,,] c1 = Functions.cultChange(ref NumOfIter, ref cultureStructure, ref jaggedArray, st, populArray); //Functions.cultChange(ref cultureStructure, ref arrayList, st, populArray);





//////////////////////////////////////////////
//System.Console.WriteLine("Введите количество тактов:");
//int NumOfIterations = int.Parse(System.Console.ReadLine());

//for (int t = 0; t < NumOfIterations; t++)
//{


//    //в двойном цикле по iz и v пробегаем все возможные сочетания стран. Если стран 5, то сочетаний будет 5*5. Это можно представить как "матрицу процессов" размером 5*5, где номер каждого элемента будет соответствовать номерам пары стран. Элементы с номерами, у которых пары индексов различны, будут представлять потоки между странами (20 шт.). Элементы с одинаковыми номерами в паре (5 шт, расположены на главной диагонали матрицы) - это процессы внутри стран. 
//    for (int iz = 0; iz < State.numberOfCountries; iz++)
//    {
//        for (int v = 0; v < State.numberOfCountries; v++)   //фиксируем iz и v. Так в двойном цикле пробежим все варианты потоков между странами (20 шт) и процессов внутри стран (условно поток из А в А) (5 шт). 
//        {
//            double a = 0.001;  //нек коэф-т (будет использоваться при расчете changeForСurrCult, changeForV, changeForIz; в дальнейшем возможно во всех трех случаях будут разные коэф-ты.)

//            //а)
//            if (iz == v)    //Если это одна и та же страна, а не поток между двумя различным странами, то перейдем к рассмотрению культурных процессов внутри одной страны. Для этого от матрицы процессов перейдем к матрице культур данной страны ("строке" куба культур) и будем работать с ней внутри двойного цикла for.
//            {
//                int indexOfLocCult = v; //сохраним номер местной культуры. (Порядковый номер страны совпадает с порядковым номером культуры, что и будет использовано далее.)

//                double[] max = { 0.0, 0.0, 0.0, 0.0, 0.0 };
//                int[] posMax = { -1, -1, -1, -1, -1 };

//                for (int i = 0; i < 5; i++)   //пробегаем строки матрицы данной страны
//                {
//                    for (int j = 0; j < 5; j++)   //пробегаем столбцы каждой строки, чтобы найти макс в этой строке
//                    {
//                        if (max[i] < cultureStructure[indexOfLocCult, i, j])
//                        {
//                            max[i] = cultureStructure[indexOfLocCult, i, j];
//                            posMax[i] = j;   //в posMaxIz надо записать последний из индексов, тк далее posMaxIz будет использоваться всегда на месте последнего индекса                          
//                        }
//                    }
//                }


//                //посчитаем численности всех культурных групп i в данной стране: 
//                double[] sum = new double[5];   //будет временно хранить 5 сумм - по строчкам матрицы в одной "строке" куба за раз. Для каждой страны (под номером indexOfLocCult) будет по пять сумм.

//                for (int iter = 0; iter < populArray.GetLength(0); iter++)
//                {
//                    for (int x = 0; x < populArray.GetLength(1); x++)  //пробегаем возраст
//                    {
//                        for (int y = 0; y < populArray.GetLength(2); y++)  //пробегаем образование
//                        {
//                            for (int z = 0; z < populArray.GetLength(3); z++)  //пробегаем культуры (в данном случае будем выбирать только одну за раз)
//                            {
//                                if (z == iter) sum[iter] += populArray[indexOfLocCult, x, y, z];//надо отойти от for (int s = 0; s < populArr.GetLength(0); s++), тк мне не нужно пробегать по всем пар-педам стран! Мне пока нужно по одному! И это фиксируем, вместо s ставя indexOfLocCult в populArr[indexOfLocCult, x, y, z]! А культуру там выбираем одну путем приравнивания z == iter!
//                            }
//                        }
//                    }
//                }



//                double changeForСurrCult;    //в случае процессов внутри одной страны changeForV и changeForIz заменил на одну обшую переменную - changeForСurrCult - тк там получается уже не важно, какая культура изначальлно своя и какие мигрантские. Все культуры начинают влиять друг на друга пропорционально своим численностям.
//                double coeff_changeForСurrCult;     //коэф-т, использующийся при расчете changeForСurrCult                           

//                for (int currCult = 0; currCult < 5; currCult++)    //пробегаем по строчкам матрицы (по четырем мигрантским и одной своей - все будут вычисляться одинаково).
//                                                                    //Ниже в  cultStruct[] вводимая здесь переменная currCult будет использована в качестве второго индекса - чтобы пробегать строки матрицы. А первый индеск здесь везде будет indexOfLocCult и меняться не будет, тк это строка куба! Она зафиксирована выше как indexOfLocCult!
//                {
//                    //Перераспределение значений внутри одной строчки:
//                    for (int i = 0; i < 5; i++)     //определим значение влияния  каждой другой культуры i на данную культуру currCult и произведем перераспределение культур между парой "данная культура currCult - другая культура i". И так при каждом i. (Для простоты будем рассматривать только взаимодействия мигрантских культур с местной и не будем учитывать взаимовлияние мигранских культур между собой - будем считать его незначительным.)
//                    {
//                        if (i != currCult)      //чтобы не было лишних вычислений (хотя в принципе это не обязательно: при i=indexOfLocCult никаких изменений делать не требуется, но и их не будет, тк в случае одной и той же культуры из нее вычтется changeForV и сразу прибавится снова, те изменений и не будет)
//                        {
//                            coeff_changeForСurrCult = a * sum[i] + 0.01;   //пришлось добавить + 0.01, тк пока численности населений мигрантов пустые, и множитель получался равным 0. Но далее после реализации потоков численности мигрантов должны постепенно начать набираться автоматически!

//                            changeForСurrCult = coeff_changeForСurrCult * cultureStructure[indexOfLocCult, i, posMax[i]];//первый индекс здесь indexOfLocCult, а не currCult, тк здесь нужен номер "строки" куба. И он должен быть неизменен во всем коде здесь (он определяется выше). А здесь мы работаем внутри одной строки куба! //второй индекс - i, те уходим из строки currCult в строку i и ищем там ее макс! А далее вернемся в строку currCult и будем ее менять.

//                            //перераспределяем значения культур между парой элементов в строке (векторе) местной культуры:                                       
//                            cultureStructure[indexOfLocCult, currCult, posMax[currCult]] -= changeForСurrCult;    //Изменение доли своей культуры j в стране j (своего культурного максимума) - уменьшение//[v, v, posMaxV] значит, что идем в "строку" v куба - попадаем в м-цу. В ней выбираем строку v и столбец posMaxV                                                              
//                            cultureStructure[indexOfLocCult, currCult, posMax[i]] += changeForСurrCult;   //Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение

//                        }
//                    }
//                }



//            }   //конец обработки процессов внутри одной страны

//            //б)
//            else  //если это не процессы в одной стране, а поток между парой разных стран, то культурные изменения будут вычисляться иначе:
//            {
//                //Сначала делаем поиск максимумов пары стран. Его нужно считать иначе, нежели в случае процессов внутри одной страны (выше) - здесь надо считать макс ПАРЫ iz и v (пара зафиксирована циклом еще выше) - макс страны-источника потока и макс своей страны.

//                //Найдем значение и порядковый номер макс культуры мигранта, значение и порядковый номер принимающей страны:
//                double maxIz = 0;
//                int posMaxIz = -1;  //-1 - те пока позиции нет

//                double maxV = 0;
//                int posMaxV = -1;

//                for (int l = 0; l < cultureStructure.GetLength(0); l++)
//                {
//                    for (int m = 0; m < cultureStructure.GetLength(1); m++)
//                    {
//                        for (int n = 0; n < cultureStructure.GetLength(2); n++)
//                        {
//                            if (l == iz && m == iz)
//                            {
//                                if (maxIz < cultureStructure[l, m, n])
//                                {
//                                    maxIz = cultureStructure[l, m, n];
//                                    posMaxIz = n;   //в posMaxIz надо записать последний из индексов, тк далее posMaxIz будет использоваться всегда на месте последнего индекса                          
//                                }
//                            }

//                            if (l == v && m == v)
//                            {
//                                if (maxV < cultureStructure[l, m, n])
//                                {
//                                    maxV = cultureStructure[l, m, n];
//                                    posMaxV = n;
//                                }
//                            }
//                        }


//                    }
//                }
//                //System.Console.WriteLine();
//                //System.Console.WriteLine("Значение макс культуры мигранта (из страны №{0}):\n{1}", iz, maxIz);
//                //System.Console.WriteLine("Номер макс культуры мигранта (из страны №{0}):\n{1}\n", iz, posMaxIz);

//                //System.Console.WriteLine("Значение макс культуры принимающей страны (страна №{0}):\n{1}", v, maxV);
//                //System.Console.WriteLine("Номер макс культуры принимающей страны (страна №{0}):\n{1} \n", v, posMaxV);
//                //System.Console.WriteLine();



//                double changeForV;    //На сколько изменяем вектор культур страны v под влиянием мигрантов из страны iz.                      
//                double coeff_changeForV;  //нек коэф-т (будет использоваться при расчете changeForV)

//                coeff_changeForV = a * st[iz].flowSize[v]; //коэф-т влияния на местное население в В зависит от размера входящего потока из А в В
//                changeForV = coeff_changeForV * cultureStructure[iz, iz, posMaxIz];//то есть окончательно влияние на местное население в В зависит от размера входящего потока из А в В и от культуры в А

//                //Окончательный результат - обмен долями между двумя значениями вектора местной культуры:
//                cultureStructure[v, v, posMaxV] -= changeForV;
//                cultureStructure[v, v, posMaxIz] += changeForV;   //Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение:


//                //Для проверки работы программы / сравнения результатов до применения изменений changeForIz ниже:
//                //arrOut3D(cultStruct);  
//                //MatVekKulStOut(cultStruct);




//                double changeForIz;  //На сколько изменяем вектор культур мигрантов, приехавших из страны iz в страну v
//                double coeff_changeForIz;

//                double sum = 0;

//                //Посчитаем числ насел в стране v культуры v:
//                for (int i = 0; i < populArray.GetLength(1); i++)  //фиксируем возраст GetLength(1), а не GetLength(0), тк последнее будет пробегать не по возрастам а странам - а у нас страна уже выбрана, поэтому начинаем сразу со второй размерности массива - те с 1
//                {
//                    for (int j = 0; j < populArray.GetLength(2); j++)  //фиксируем образование
//                    {
//                        for (int k = 0; k < populArray.GetLength(3); k++)  //пробегаем все культуры
//                        {
//                            if (k == v) sum += populArray[v, i, j, k];   //if (k != iz) sum += populArr[v, i, j, k]; - если во влиянии учитывать не только людей преобладающей культуры, но и всех остальных, только где культура не совпадает с культурой iz. В текущей версии считаем влияние остальных культур на iz пренебрежительно малым в момент прибытия волны из iz.
//                        }
//                    }
//                }

//                coeff_changeForIz = a * (1.0 - 1.0 / sum);  //влияние на мигрантов является функцией от суммы численности местного населения sum, у которого культура является преобладающей в данной стране. 
//                                                            //Как считается: сумме sum ставим в соответствие нек число между 0 и 1, чтобы коэф-т coeff_changeForIz был похож по величине на coeff_changeForV. Для этого делим 1.0 / sum. Но здесь чем больше сумма, тем меньше будет дробь, а нам нужно наоборот (чем больше население другой культуры, тем больше должно быть влияние), поэтому будем вычитать эту величину из единицы: 1.0 - 1.0 / sum.
//                                                            //Поправочный коэф-т а используется для того, чтобы значения не были слишком большими.
//                changeForIz = coeff_changeForIz * cultureStructure[v, v, posMaxV];    //окончательное влияние на мигрантов будет зависеть от численности населения преобладающей в стране культуры и от значения ("силы") этой культуры                                                                                         

//                //Окончательный результат - обмен долями между двумя значениями вектора мигрантов iz, приехавших в страну v: 
//                cultureStructure[v, iz, posMaxIz] -= changeForIz; //Изменение доли своей культуры (своего культурного максимума) - уменьшение
//                cultureStructure[v, iz, posMaxV] += changeForIz;  //Изменение доли культуры страны (культурного максимума страны) - увеличение

//            }


//        }
//    }

//    double[,,] currCultStr = new double[5, 5, 5]; //Создание нового объекта currCultStr НЕОБХОДИМО при КАЖДОЙ итерации по t/NumOfIterations! эта строчка должна быть внутри цикла по кол-ву итераций, и вынести ее из цикла вверх нельзя! Потому что если объявить объект currCultStr выше цикла, то объявление произойдет всего один раз, и объект получит какой-то ОДИН адрес. Далее в конце каждого цикла копирование "Array.Copy(cultureStructure, currCultStr, 125);" будет происходить на один и тот же адрес, после чего "arrayList.Add(currCultStr);" будет добавлять в конец списка ссылку на все тот же один адрес - и в итоге список будет заполнен одинаковыми экземплярами! Значение которых будет равно значению последней из струкур, те значению с последней итерации! А чтобы значения были разными, нужно создавать новый объект currCultStr при КАЖДОЙ итерации! Тогда каждый раз у него будет свой адрес, и в итоге в списке будут храниться ссылки на разные адреса, что и позволит все записать правильно! И + еще нужно использовать "Array.Copy(cultureStructure, currCultStr, 125);" (см комментарий к строке с Array.Copy), чтобы при каждой итерации копировалось значение, а не ссылка. Это все нужно из-за того, что делаем это внутри цикла, тк при выходе из цикла связи по сссылкам нарушаются! Т.о., из-за вычислений внутри цикла нужна как эта строка здесь, так и строка с Array.Copy ниже, и они должны обе быть вунтри цикла по t. 
//    Array.Copy(cultureStructure, currCultStr, 125); //Нам нужно передать значение cultureStructure на каждой итерации в arrayList - именно значение, а не ссылку на cultureStructure, поэтому надо использовать Array.Copy, а не просто присваивание "currCultStr = cultureStructure;"! Если написать "currCultStr = cultureStructure;", то будет передано не знач cultureStructure, а ссылка на cultureStructure! Разница здесь важна, пскольку мы находимся внутри цикла! При "currCultStr = cultureStructure;" на всех итерациях ссылка будет одна и та же - на cultureStructure! И если внутри цикла это ссылки на разные cultureStructure, существующие внутри цикла, то при выходе цикла это все становится ссылками на один и тот же cultureStructure, тк вне цикла он сущ-ет только в одном экземпляре! Поэтому для копир значений нужно использовать Array.Copy!
//    arrayList.Add(currCultStr);



//    //К концу шага имеем:     
//    System.Console.WriteLine("-----------------------------После такта №{0}:-------------------------------", t);
//    Functions.arrOut3D(cultureStructure);
//    Functions.MatVekKulStOut(cultureStructure);

//}

////////////////////////////////////////








//public static double[,,] cultChange2(ref int NumOfIter, ref double[,,] cultStruct, ref double[][,,] jaggedArr, State[] state, double[,,,] populArr) // изменение культур в каждой стране по тактам.                                                                                                                
//{
//    //К культурным изменениям как и у мигрантов, так и у местного населения в каждой стране приводят следующие процессы:
//    //а) внутренние процессы культурного взаимовлияния в каждой стране;
//    //б) потоки мигрантов между странами.

//    //В данной функции задается как механизм внутренних процессов, так и механизм потокового влияния. Задаются они отдельно друг от друга, тк их природа различается.            

//    //Случай внутренних процессов:
//    //Будем считать, что внутри страны все культурные группы влияют друг на друга. Влияние каждой культурной группы на остальные определяется ее численностью населения и культурным максимумом.

//    //Случай потоков:
//    //Будем считать, что миграционная волна из страны А в страну В по прибытии в страну В сначала имеет дело преимущественно с преобладающей в В культурой. Поэтому будем считать, что для прибывающего потока мигрантов на начальном этапе происходит взаимовлияние культур только с преобладающей культурой принимающей стороны, а взаимовлиянием с остальными культурами этой страны на данном этапе можно пренебречь. А далее, проживая в стране и начиная участвовать во внутренних процессах страны, мигранты начинают взаимодействовать и с другими группами мигрантов, и начинается взаимовлияние культур и с ними тоже.
//    //Таким образом:
//    //- влияние на местное население в В зависит от размера входящего потока из А в В и от культуры в А;
//    //- влияние на мигрантов из А в В будет зависеть от численности населения преобладающей в стране В культуры и от значения ("силы") этой культуры.

//    System.Console.WriteLine("Введите количество тактов:");
//    int NumOfIterations = int.Parse(System.Console.ReadLine());
//    NumOfIter = NumOfIterations;

//    double[,,] cc = cultStruct;

//    for (int t = 0; t < NumOfIterations; t++)
//    {

//        //в двойном цикле по iz и v пробегаем все возможные сочетания стран. Если стран 5, то сочетаний будет 5*5. Это можно представить как "матрицу процессов" размером 5*5, где номер каждого элемента будет соответствовать номерам пары стран. Элементы с номерами, у которых пары индексов различны, будут представлять потоки между странами (20 шт.). Элементы с одинаковыми номерами в паре (5 шт, расположены на главной диагонали матрицы) - это процессы внутри стран. 
//        for (int iz = 0; iz < State.numberOfCountries; iz++)
//        {
//            for (int v = 0; v < State.numberOfCountries; v++)   //фиксируем iz и v. Так в двойном цикле пробежим все варианты потоков между странами (20 шт) и процессов внутри стран (условно поток из А в А) (5 шт). 
//            {
//                double a = 0.001;  //нек коэф-т (будет использоваться при расчете changeForСurrCult, changeForV, changeForIz; в дальнейшем возможно во всех трех случаях будут разные коэф-ты.)


//                //а)
//                if (iz == v)    //Если это одна и та же страна, а не поток между двумя различным странами, то перейдем к рассмотрению культурных процессов внутри одной страны. Для этого от матрицы процессов перейдем к матрице культур данной страны ("строке" куба культур) и будем работать с ней внутри двойного цикла for.
//                {
//                    int indexOfLocCult = v; //сохраним номер местной культуры. (Порядковый номер страны совпадает с порядковым номером культуры, что и будет использовано далее.)

//                    double[] max = { 0.0, 0.0, 0.0, 0.0, 0.0 };
//                    int[] posMax = { -1, -1, -1, -1, -1 };

//                    for (int i = 0; i < 5; i++)   //пробегаем строки матрицы данной страны
//                    {
//                        for (int j = 0; j < 5; j++)   //пробегаем столбцы каждой строки, чтобы найти макс в этой строке
//                        {
//                            if (max[i] < cultStruct[indexOfLocCult, i, j])
//                            {
//                                max[i] = cultStruct[indexOfLocCult, i, j];
//                                posMax[i] = j;   //в posMaxIz надо записать последний из индексов, тк далее posMaxIz будет использоваться всегда на месте последнего индекса                          
//                            }
//                        }
//                    }


//                    //посчитаем численности всех культурных групп i в данной стране: 
//                    double[] sum = new double[5];   //будет временно хранить 5 сумм - по строчкам матрицы в одной "строке" куба за раз. Для каждой страны (под номером indexOfLocCult) будет по пять сумм.

//                    for (int iter = 0; iter < populArr.GetLength(0); iter++)
//                    {
//                        for (int x = 0; x < populArr.GetLength(1); x++)  //пробегаем возраст
//                        {
//                            for (int y = 0; y < populArr.GetLength(2); y++)  //пробегаем образование
//                            {
//                                for (int z = 0; z < populArr.GetLength(3); z++)  //пробегаем культуры (в данном случае будем выбирать только одну за раз)
//                                {
//                                    if (z == iter) sum[iter] += populArr[indexOfLocCult, x, y, z];//надо отойти от for (int s = 0; s < populArr.GetLength(0); s++), тк мне не нужно пробегать по всем пар-педам стран! Мне пока нужно по одному! И это фиксируем, вместо s ставя indexOfLocCult в populArr[indexOfLocCult, x, y, z]! А культуру там выбираем одну путем приравнивания z == iter!
//                                }
//                            }
//                        }
//                    }



//                    double changeForСurrCult;    //в случае процессов внутри одной страны changeForV и changeForIz заменил на одну обшую переменную - changeForСurrCult - тк там получается уже не важно, какая культура изначальлно своя и какие мигрантские. Все культуры начинают влиять друг на друга пропорционально своим численностям.
//                    double coeff_changeForСurrCult;     //коэф-т, использующийся при расчете changeForСurrCult                           

//                    for (int currCult = 0; currCult < 5; currCult++)    //пробегаем по строчкам матрицы (по четырем мигрантским и одной своей - все будут вычисляться одинаково).
//                                                                        //Ниже в  cultStruct[] вводимая здесь переменная currCult будет использована в качестве второго индекса - чтобы пробегать строки матрицы. А первый индеск здесь везде будет indexOfLocCult и меняться не будет, тк это строка куба! Она зафиксирована выше как indexOfLocCult!
//                    {
//                        //Перераспределение значений внутри одной строчки:
//                        for (int i = 0; i < 5; i++)     //определим значение влияния  каждой другой культуры i на данную культуру currCult и произведем перераспределение культур между парой "данная культура currCult - другая культура i". И так при каждом i. (Для простоты будем рассматривать только взаимодействия мигрантских культур с местной и не будем учитывать взаимовлияние мигранских культур между собой - будем считать его незначительным.)
//                        {
//                            if (i != currCult)      //чтобы не было лишних вычислений (хотя в принципе это не обязательно: при i=indexOfLocCult никаких изменений делать не требуется, но и их не будет, тк в случае одной и той же культуры из нее вычтется changeForV и сразу прибавится снова, те изменений и не будет)
//                            {
//                                coeff_changeForСurrCult = a * sum[i] + 0.01;   //пришлось добавить + 0.01, тк пока численности населений мигрантов пустые, и множитель получался равным 0. Но далее после реализации потоков численности мигрантов должны постепенно начать набираться автоматически!

//                                changeForСurrCult = coeff_changeForСurrCult * cultStruct[indexOfLocCult, i, posMax[i]];//первый индекс здесь indexOfLocCult, а не currCult, тк здесь нужен номер "строки" куба. И он должен быть неизменен во всем коде здесь (он определяется выше). А здесь мы работаем внутри одной строки куба! //второй индекс - i, те уходим из строки currCult в строку i и ищем там ее макс! А далее вернемся в строку currCult и будем ее менять.

//                                //перераспределяем значения культур между парой элементов в строке (векторе) местной культуры:                                       
//                                cultStruct[indexOfLocCult, currCult, posMax[currCult]] -= changeForСurrCult;    //Изменение доли своей культуры j в стране j (своего культурного максимума) - уменьшение//[v, v, posMaxV] значит, что идем в "строку" v куба - попадаем в м-цу. В ней выбираем строку v и столбец posMaxV                                                              
//                                cultStruct[indexOfLocCult, currCult, posMax[i]] += changeForСurrCult;   //Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение

//                            }
//                        }
//                    }



//                }   //конец обработки процессов внутри одной страны

//                //б)
//                else  //если это не процессы в одной стране, а поток между парой разных стран, то культурные изменения будут вычисляться иначе:
//                {
//                    //Сначала делаем поиск максимумов пары стран. Его нужно считать иначе, нежели в случае процессов внутри одной страны (выше) - здесь надо считать макс ПАРЫ iz и v (пара зафиксирована циклом еще выше) - макс страны-источника потока и макс своей страны.

//                    //Найдем значение и порядковый номер макс культуры мигранта, значение и порядковый номер принимающей страны:
//                    double maxIz = 0;
//                    int posMaxIz = -1;  //-1 - те пока позиции нет

//                    double maxV = 0;
//                    int posMaxV = -1;

//                    for (int l = 0; l < cultStruct.GetLength(0); l++)
//                    {
//                        for (int m = 0; m < cultStruct.GetLength(1); m++)
//                        {
//                            for (int n = 0; n < cultStruct.GetLength(2); n++)
//                            {
//                                if (l == iz && m == iz)
//                                {
//                                    if (maxIz < cultStruct[l, m, n])
//                                    {
//                                        maxIz = cultStruct[l, m, n];
//                                        posMaxIz = n;   //в posMaxIz надо записать последний из индексов, тк далее posMaxIz будет использоваться всегда на месте последнего индекса                          
//                                    }
//                                }

//                                if (l == v && m == v)
//                                {
//                                    if (maxV < cultStruct[l, m, n])
//                                    {
//                                        maxV = cultStruct[l, m, n];
//                                        posMaxV = n;
//                                    }
//                                }
//                            }


//                        }
//                    }
//                    //System.Console.WriteLine();
//                    //System.Console.WriteLine("Значение макс культуры мигранта (из страны №{0}):\n{1}", iz, maxIz);
//                    //System.Console.WriteLine("Номер макс культуры мигранта (из страны №{0}):\n{1}\n", iz, posMaxIz);

//                    //System.Console.WriteLine("Значение макс культуры принимающей страны (страна №{0}):\n{1}", v, maxV);
//                    //System.Console.WriteLine("Номер макс культуры принимающей страны (страна №{0}):\n{1} \n", v, posMaxV);
//                    //System.Console.WriteLine();



//                    double changeForV;    //На сколько изменяем вектор культур страны v под влиянием мигрантов из страны iz.                      
//                    double coeff_changeForV;  //нек коэф-т (будет использоваться при расчете changeForV)

//                    coeff_changeForV = a * state[iz].flowSize[v]; //коэф-т влияния на местное население в В зависит от размера входящего потока из А в В
//                    changeForV = coeff_changeForV * cultStruct[iz, iz, posMaxIz];//то есть окончательно влияние на местное население в В зависит от размера входящего потока из А в В и от культуры в А

//                    //Окончательный результат - обмен долями между двумя значениями вектора местной культуры:
//                    cultStruct[v, v, posMaxV] -= changeForV;
//                    cultStruct[v, v, posMaxIz] += changeForV;   //Изменение доли культуры страны i в векторе страны j (под влиянием культурного максимума страны i, которым обладают мигранты) - увеличение:


//                    //Для проверки работы программы / сравнения результатов до применения изменений changeForIz ниже:
//                    //arrOut3D(cultStruct);  
//                    //MatVekKulStOut(cultStruct);




//                    double changeForIz;  //На сколько изменяем вектор культур мигрантов, приехавших из страны iz в страну v
//                    double coeff_changeForIz;

//                    double sum = 0;

//                    //Посчитаем числ насел в стране v культуры v:
//                    for (int i = 0; i < populArr.GetLength(1); i++)  //фиксируем возраст GetLength(1), а не GetLength(0), тк последнее будет пробегать не по возрастам а странам - а у нас страна уже выбрана, поэтому начинаем сразу со второй размерности массива - те с 1
//                    {
//                        for (int j = 0; j < populArr.GetLength(2); j++)  //фиксируем образование
//                        {
//                            for (int k = 0; k < populArr.GetLength(3); k++)  //пробегаем все культуры
//                            {
//                                if (k == v) sum += populArr[v, i, j, k];   //if (k != iz) sum += populArr[v, i, j, k]; - если во влиянии учитывать не только людей преобладающей культуры, но и всех остальных, только где культура не совпадает с культурой iz. В текущей версии считаем влияние остальных культур на iz пренебрежительно малым в момент прибытия волны из iz.
//                            }
//                        }
//                    }

//                    coeff_changeForIz = a * (1.0 - 1.0 / sum);  //влияние на мигрантов является функцией от суммы численности местного населения sum, у которого культура является преобладающей в данной стране. 
//                                                                //Как считается: сумме sum ставим в соответствие нек число между 0 и 1, чтобы коэф-т coeff_changeForIz был похож по величине на coeff_changeForV. Для этого делим 1.0 / sum. Но здесь чем больше сумма, тем меньше будет дробь, а нам нужно наоборот (чем больше население другой культуры, тем больше должно быть влияние), поэтому будем вычитать эту величину из единицы: 1.0 - 1.0 / sum.
//                                                                //Поправочный коэф-т а используется для того, чтобы значения не были слишком большими.
//                    changeForIz = coeff_changeForIz * cultStruct[v, v, posMaxV];    //окончательное влияние на мигрантов будет зависеть от численности населения преобладающей в стране культуры и от значения ("силы") этой культуры                                                                                         

//                    //Окончательный результат - обмен долями между двумя значениями вектора мигрантов iz, приехавших в страну v: 
//                    cultStruct[v, iz, posMaxIz] -= changeForIz; //Изменение доли своей культуры (своего культурного максимума) - уменьшение
//                    cultStruct[v, iz, posMaxV] += changeForIz;  //Изменение доли культуры страны (культурного максимума страны) - увеличение

//                }


//            }
//        }



//        //arrList.Add(cultStruct);    //arrList заполняется правильно, но в программе список заполняется одинаковыми элзми - последними!

//        //    for (int i = 0; i < State.numberOfCountries; i++)
//        //    {
//        //        System.Console.Write("in current cultStruct: {0}\t", cultStruct[0, 1, i]);
//        //        System.Console.WriteLine("copied to list: {0}\t", arrList[arrList.Count-1][0, 1, i]);
//        //    }
//        //    System.Console.WriteLine();



//        //Program.jaggedArray[t] = cultStruct;
//        //jaggedArr[t] = cultStruct;
//        //Array.Copy(cultStruct, jaggedArr[t], 125);
//        if (t == 1) cc = cultStruct;

//        //К концу шага имеем:     
//        System.Console.WriteLine("-----------------------------После такта №{0}:-------------------------------", t);
//        arrOut3D(cultStruct);
//        MatVekKulStOut(cultStruct);


//    }
//    return cc;
//}



//public static void cultEduChange(double[,,] tolStruct, State[] state)
//{

//    for (int s = 0; s < State.numberOfCountries; s++)
//    {
//        for (int i = 0; i < State.numberOfCountries; i++)
//        {
//            for (int j = 0; j < State.numberOfCountries; j++)
//            {
//                if (tolStruct[s, i, j] != 1) tolStruct[s, i, j] += tolStruct[s, i, j] * state[s].eduCultResource;
//            }
//        }
//    }
//    System.Console.WriteLine("-------Структура матриц толерантности после cultEduChange:------");
//    arrOut3D(tolStruct);

//}








//private void chart1Click(object sender, EventArgs e)
//{

//}

//private void button1_Click(object sender, EventArgs e)
//{
//    //Random rdn = new Random();
//    //for (int i = 0; i < 50; i++)
//    //{
//    //    chartTest.Series["Series1"].Points.AddXY(rdn.Next(0, 10), rdn.Next(0, 10));
//    //    chartTest.Series["Series2"].Points.AddXY(rdn.Next(0, 10), rdn.Next(0, 10));
//    //}

//    //chartTest.Series["Series1"].ChartType = SeriesChartType.FastLine;
//    //chartTest.Series["Series1"].Color = Color.Red;

//    //chartTest.Series["Series2"].ChartType = SeriesChartType.FastLine;
//    //chartTest.Series["Series2"].Color = Color.Blue;

//}

//private void button2_Click(object sender, EventArgs e)
//{
//    //chartTest.Series["Series4"].ChartType = SeriesChartType.Point; //изменить представление графика с линии на точечное (можно добавить еще одну кнопку для обратного действия)
//}

//private void button3_Click(object sender, EventArgs e)
//{

//    //double[] array = { 2.8, 4.4, 6.5, 8.3, 3.6, 5.6, 7.3, 9.2, 1.0 };
//    //chart1.Series["Series5"].Points.DataBindY(array); // Bind the double array to the Y axis points of the data series.

//    //List<Series> newSeries = new List<Series>();

//    //for (int l = 0; l < Program.cultarrayList.Count; l++) //for (int l = 0; l < Program.cultarrayList.Count; l++) //сколько графиков (линий) строить
//    //{

//    //    string seriesName = l.ToString();
//    //    chart2.Series.Add(seriesName);
//    //    chart2.Series[seriesName].ChartType = SeriesChartType.Line;
//    //    chart2.Series[seriesName].BorderWidth = 1;
//    //    chart2.Series[seriesName].ChartArea = "ChartArea1"; //chart1.Series[seriesName].ChartArea = "ChartArea3";

//    //    for (int i = 0; i < State.numberOfCountries; i++)   //что делать с каждым графиком (линией)
//    //    {
//    //        chart2.Series[seriesName].Points.AddXY(i, Program.cultarrayList[l][0, 1, i]);//вывести в-р из 0й строки куба, 1й строки м-цы (и так для каждого такта l)
//    //        //System.Console.Write("x: {0}, y: {1}\t", i, Program.cultarrayList[l][0, 1, i]);

//    //    }
//    //    System.Console.WriteLine();
//    //}       
//}






//вариант со стабильной страной 1 и постепенно вымирающими остальными:
//state[0].bCoeff_activePeople = 0.119;   // 0.119 лучше, чем 0.019. //уже 0.129 приводит к эксп росту населения
//state[1].bCoeff_activePeople = 0.103;   //0.028 лучше, чем 0.018. //0.108 приводит к эксп росту населения почему-то! И появляются отриц значения в культурах этой страны! //0.098;
//state[2].bCoeff_activePeople = 0.02;    //0.12 эксп нет, но приводит к оч большому росту в странах 0-3! Во всех! И через 100 лет в 0,1,3 половина мигрантов!
//state[3].bCoeff_activePeople = 0.02;    //0.12 приводит к эксп росту и отр культ у 0 и 3!
//state[4].bCoeff_activePeople = 0.02;     //0.12 эксп нет но приводит к оч большому росту в 4 

//state[0].dCoeff_activePeople = 0.001;
//state[1].dCoeff_activePeople = 0.003; //по сравн с 0.002, 0.0002 через 100 лет увеличивает числ взрослых и стариков (причем стариков сильнее - но это мб потому что у меня их и так намного больше) 
//state[2].dCoeff_activePeople = 0.005;
//state[3].dCoeff_activePeople = 0.001;
//state[4].dCoeff_activePeople = 0.003;

//state[0].dCoeff_elders = 0.0035;   
//state[1].dCoeff_elders = 0.049;//0.011; //0.015 делает картину долее умеренной; все еще с приростом общего насел через 100 лет. 0.019 через 100 лет возвращает выраставшую числ к исходному значению //0.025; //0.029
//state[2].dCoeff_elders = 0.003;
//state[3].dCoeff_elders = 0.002;
//state[4].dCoeff_elders = 0.003;





//бол-мен стабильная демография, но вымирающая (так работало вроде на прос спос 10%):
//state[0].bCoeff_activePeople = 0.019;
//state[1].bCoeff_activePeople = 0.018;
//state[2].bCoeff_activePeople = 0.02;
//state[3].bCoeff_activePeople = 0.02;
//state[4].bCoeff_activePeople = 0.02;

//state[0].dCoeff_activePeople = 0.001;
//state[1].dCoeff_activePeople = 0.002;
//state[2].dCoeff_activePeople = 0.005;
//state[3].dCoeff_activePeople = 0.001;
//state[4].dCoeff_activePeople = 0.003;

//state[0].dCoeff_elders = 0.0015;
//state[1].dCoeff_elders = 0.001;
//state[2].dCoeff_elders = 0.003;
//state[3].dCoeff_elders = 0.002;
//state[4].dCoeff_elders = 0.003;






//for (int i = 0; i < State.numberOfCountries; i++)  //фиксируем культуру, У которой будем определять толерантность к другим культурам в данной стране
//{
//    for (int j = 0; j < State.numberOfCountries; j++)  //фиксируем культуру, К которой будем определять толерантность
//    {
//        if ((tolStruct[s, i, j] < criticalInstab) && (state[s].shareOfMigrants > 0) ) state[s].socInstabilityIndex++;
//        //но если tolStruct[s, i, j] < criticalInstab, а численности групп i, j будут нулевые - может посчитать неверно! Если будет shareOfMigrants > 0 из-за других мигрантов! Надо переделать как сдлеано для маркеров - код оттуда надо поместить сюда!
//    }
//}